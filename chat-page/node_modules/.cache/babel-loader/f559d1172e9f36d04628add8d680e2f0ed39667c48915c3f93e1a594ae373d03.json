{"ast":null,"code":"var _jsxFileName = \"/home/mehdycament/Bureau/app_message_symfony/chat-page/src/contexts/ChatContext.js\",\n  _s = $RefreshSig$();\nimport React, { createContext, useState, useEffect, useContext } from 'react';\nimport { AuthContext } from './AuthContext';\nimport io from 'socket.io-client';\nimport { jsxDEV as _jsxDEV } from \"react/jsx-dev-runtime\";\nexport const ChatContext = /*#__PURE__*/createContext();\n\n// URL du serveur socket.io\nconst SOCKET_URL = 'http://localhost:5000';\nlet socket;\nexport const ChatProvider = ({\n  children\n}) => {\n  _s();\n  const {\n    currentUser\n  } = useContext(AuthContext);\n  const [onlineUsers, setOnlineUsers] = useState([]);\n  const [selectedUser, setSelectedUser] = useState(null);\n  const [messages, setMessages] = useState([]);\n  const [loading, setLoading] = useState(false);\n  const [connected, setConnected] = useState(false);\n\n  // Établir la connexion socket quand l'utilisateur est connecté\n  useEffect(() => {\n    if (currentUser && !socket) {\n      // Initialiser la connexion socket\n      socket = io(SOCKET_URL);\n\n      // Connexion établie\n      socket.on('connect', () => {\n        console.log('Connecté au serveur socket');\n        setConnected(true);\n\n        // Enregistrer/connecter l'utilisateur sur le serveur socket\n        socket.emit('register', currentUser);\n      });\n\n      // Écouter les utilisateurs en ligne\n      socket.on('users_update', users => {\n        // Filtrer pour exclure l'utilisateur courant\n        const otherUsers = users.filter(user => user.id !== currentUser.id && user.isOnline);\n        setOnlineUsers(otherUsers);\n      });\n\n      // Écouter les nouveaux messages\n      socket.on('new_message', message => {\n        setMessages(prevMessages => [...prevMessages, message]);\n      });\n\n      // Confirmation d'envoi de message\n      socket.on('message_sent', message => {\n        setMessages(prevMessages => prevMessages.map(msg => msg.id === message.id ? message : msg));\n      });\n\n      // Écouter les nouvelles réactions\n      socket.on('new_reaction', ({\n        messageId,\n        reaction,\n        userId\n      }) => {\n        setMessages(prevMessages => prevMessages.map(msg => msg.id === messageId ? {\n          ...msg,\n          reactions: [...(msg.reactions || []), {\n            reaction,\n            userId\n          }]\n        } : msg));\n      });\n\n      // Écouter les nouvelles réponses\n      socket.on('new_reply', ({\n        messageId,\n        reply\n      }) => {\n        setMessages(prevMessages => prevMessages.map(msg => msg.id === messageId ? {\n          ...msg,\n          replies: [...(msg.replies || []), reply]\n        } : msg));\n      });\n\n      // Gérer la déconnexion\n      socket.on('disconnect', () => {\n        console.log('Déconnecté du serveur socket');\n        setConnected(false);\n      });\n    }\n    return () => {\n      if (socket) {\n        socket.disconnect();\n      }\n    };\n  }, [currentUser]);\n\n  // Charger les messages lorsqu'un utilisateur est sélectionné\n  useEffect(() => {\n    if (selectedUser) {\n      setLoading(true);\n      setMessages([]); // Réinitialiser les messages\n\n      // Dans une vraie application, on récupérerait l'historique des messages depuis le serveur\n      setLoading(false);\n    }\n  }, [selectedUser]);\n\n  // Charger la liste des utilisateurs\n  const fetchUsers = async () => {\n    if (!connected || !socket) return [];\n    return onlineUsers;\n  };\n\n  // Envoyer un message\n  const handleSendMessage = async content => {\n    if (!selectedUser || !currentUser || !connected) return;\n    try {\n      const newMessage = {\n        sender: currentUser.id,\n        receiver: selectedUser.id,\n        content,\n        timestamp: new Date().toISOString(),\n        status: 'sending'\n      };\n\n      // Ajouter le message localement avant d'obtenir une réponse du serveur\n      setMessages(prevMessages => [...prevMessages, newMessage]);\n\n      // Envoyer le message via socket\n      socket.emit('send_message', newMessage);\n    } catch (error) {\n      console.error('Error sending message:', error);\n    }\n  };\n\n  // Ajouter une réaction à un message\n  const handleAddReaction = async (messageId, reaction) => {\n    try {\n      if (!currentUser || !connected) return;\n\n      // Mettre à jour localement\n      setMessages(prevMessages => prevMessages.map(msg => msg.id === messageId ? {\n        ...msg,\n        reactions: [...(msg.reactions || []), {\n          reaction,\n          userId: currentUser.id\n        }]\n      } : msg));\n\n      // Envoyer via socket\n      socket.emit('add_reaction', {\n        messageId,\n        reaction,\n        userId: currentUser.id\n      });\n    } catch (error) {\n      console.error('Error adding reaction:', error);\n    }\n  };\n\n  // Répondre à un message\n  const handleReplyToMessage = async (messageId, content) => {\n    try {\n      if (!currentUser || !selectedUser || !connected) return;\n      const reply = {\n        sender: currentUser.id,\n        content,\n        timestamp: new Date().toISOString(),\n        parentId: messageId\n      };\n\n      // Mettre à jour localement\n      setMessages(prevMessages => prevMessages.map(msg => msg.id === messageId ? {\n        ...msg,\n        replies: [...(msg.replies || []), reply]\n      } : msg));\n\n      // Envoyer via socket\n      socket.emit('reply_to_message', {\n        messageId,\n        reply\n      });\n    } catch (error) {\n      console.error('Error replying to message:', error);\n    }\n  };\n  return /*#__PURE__*/_jsxDEV(ChatContext.Provider, {\n    value: {\n      onlineUsers,\n      fetchUsers,\n      selectedUser,\n      setSelectedUser,\n      messages,\n      loading,\n      handleSendMessage,\n      handleAddReaction,\n      handleReplyToMessage,\n      socketConnected: connected\n    },\n    children: children\n  }, void 0, false, {\n    fileName: _jsxFileName,\n    lineNumber: 195,\n    columnNumber: 5\n  }, this);\n};\n_s(ChatProvider, \"O5elWfyONr7vQkWzPzoNOfhMEKs=\");\n_c = ChatProvider;\nvar _c;\n$RefreshReg$(_c, \"ChatProvider\");","map":{"version":3,"names":["React","createContext","useState","useEffect","useContext","AuthContext","io","jsxDEV","_jsxDEV","ChatContext","SOCKET_URL","socket","ChatProvider","children","_s","currentUser","onlineUsers","setOnlineUsers","selectedUser","setSelectedUser","messages","setMessages","loading","setLoading","connected","setConnected","on","console","log","emit","users","otherUsers","filter","user","id","isOnline","message","prevMessages","map","msg","messageId","reaction","userId","reactions","reply","replies","disconnect","fetchUsers","handleSendMessage","content","newMessage","sender","receiver","timestamp","Date","toISOString","status","error","handleAddReaction","handleReplyToMessage","parentId","Provider","value","socketConnected","fileName","_jsxFileName","lineNumber","columnNumber","_c","$RefreshReg$"],"sources":["/home/mehdycament/Bureau/app_message_symfony/chat-page/src/contexts/ChatContext.js"],"sourcesContent":["import React, { createContext, useState, useEffect, useContext } from 'react';\nimport { AuthContext } from './AuthContext';\nimport io from 'socket.io-client';\n\nexport const ChatContext = createContext();\n\n// URL du serveur socket.io\nconst SOCKET_URL = 'http://localhost:5000';\nlet socket;\n\nexport const ChatProvider = ({ children }) => {\n  const { currentUser } = useContext(AuthContext);\n  const [onlineUsers, setOnlineUsers] = useState([]);\n  const [selectedUser, setSelectedUser] = useState(null);\n  const [messages, setMessages] = useState([]);\n  const [loading, setLoading] = useState(false);\n  const [connected, setConnected] = useState(false);\n\n  // Établir la connexion socket quand l'utilisateur est connecté\n  useEffect(() => {\n    if (currentUser && !socket) {\n      // Initialiser la connexion socket\n      socket = io(SOCKET_URL);\n      \n      // Connexion établie\n      socket.on('connect', () => {\n        console.log('Connecté au serveur socket');\n        setConnected(true);\n        \n        // Enregistrer/connecter l'utilisateur sur le serveur socket\n        socket.emit('register', currentUser);\n      });\n      \n      // Écouter les utilisateurs en ligne\n      socket.on('users_update', (users) => {\n        // Filtrer pour exclure l'utilisateur courant\n        const otherUsers = users.filter(user => \n          user.id !== currentUser.id && user.isOnline\n        );\n        setOnlineUsers(otherUsers);\n      });\n      \n      // Écouter les nouveaux messages\n      socket.on('new_message', (message) => {\n        setMessages(prevMessages => [...prevMessages, message]);\n      });\n      \n      // Confirmation d'envoi de message\n      socket.on('message_sent', (message) => {\n        setMessages(prevMessages => \n          prevMessages.map(msg => \n            msg.id === message.id ? message : msg\n          )\n        );\n      });\n      \n      // Écouter les nouvelles réactions\n      socket.on('new_reaction', ({ messageId, reaction, userId }) => {\n        setMessages(prevMessages => \n          prevMessages.map(msg => \n            msg.id === messageId \n              ? { \n                  ...msg, \n                  reactions: [...(msg.reactions || []), { reaction, userId }] \n                } \n              : msg\n          )\n        );\n      });\n      \n      // Écouter les nouvelles réponses\n      socket.on('new_reply', ({ messageId, reply }) => {\n        setMessages(prevMessages => \n          prevMessages.map(msg => \n            msg.id === messageId \n              ? { \n                  ...msg, \n                  replies: [...(msg.replies || []), reply] \n                } \n              : msg\n          )\n        );\n      });\n      \n      // Gérer la déconnexion\n      socket.on('disconnect', () => {\n        console.log('Déconnecté du serveur socket');\n        setConnected(false);\n      });\n    }\n    \n    return () => {\n      if (socket) {\n        socket.disconnect();\n      }\n    };\n  }, [currentUser]);\n\n  // Charger les messages lorsqu'un utilisateur est sélectionné\n  useEffect(() => {\n    if (selectedUser) {\n      setLoading(true);\n      setMessages([]); // Réinitialiser les messages\n      \n      // Dans une vraie application, on récupérerait l'historique des messages depuis le serveur\n      setLoading(false);\n    }\n  }, [selectedUser]);\n\n  // Charger la liste des utilisateurs\n  const fetchUsers = async () => {\n    if (!connected || !socket) return [];\n    return onlineUsers;\n  };\n\n  // Envoyer un message\n  const handleSendMessage = async (content) => {\n    if (!selectedUser || !currentUser || !connected) return;\n    \n    try {\n      const newMessage = {\n        sender: currentUser.id,\n        receiver: selectedUser.id,\n        content,\n        timestamp: new Date().toISOString(),\n        status: 'sending'\n      };\n      \n      // Ajouter le message localement avant d'obtenir une réponse du serveur\n      setMessages(prevMessages => [...prevMessages, newMessage]);\n      \n      // Envoyer le message via socket\n      socket.emit('send_message', newMessage);\n    } catch (error) {\n      console.error('Error sending message:', error);\n    }\n  };\n\n  // Ajouter une réaction à un message\n  const handleAddReaction = async (messageId, reaction) => {\n    try {\n      if (!currentUser || !connected) return;\n      \n      // Mettre à jour localement\n      setMessages(prevMessages => \n        prevMessages.map(msg => \n          msg.id === messageId \n            ? { \n                ...msg, \n                reactions: [...(msg.reactions || []), { reaction, userId: currentUser.id }] \n              } \n            : msg\n        )\n      );\n      \n      // Envoyer via socket\n      socket.emit('add_reaction', { messageId, reaction, userId: currentUser.id });\n    } catch (error) {\n      console.error('Error adding reaction:', error);\n    }\n  };\n\n  // Répondre à un message\n  const handleReplyToMessage = async (messageId, content) => {\n    try {\n      if (!currentUser || !selectedUser || !connected) return;\n      \n      const reply = {\n        sender: currentUser.id,\n        content,\n        timestamp: new Date().toISOString(),\n        parentId: messageId\n      };\n      \n      // Mettre à jour localement\n      setMessages(prevMessages => \n        prevMessages.map(msg => \n          msg.id === messageId \n            ? { \n                ...msg, \n                replies: [...(msg.replies || []), reply] \n              } \n            : msg\n        )\n      );\n      \n      // Envoyer via socket\n      socket.emit('reply_to_message', { messageId, reply });\n    } catch (error) {\n      console.error('Error replying to message:', error);\n    }\n  };\n\n  return (\n    <ChatContext.Provider\n      value={{\n        onlineUsers,\n        fetchUsers,\n        selectedUser,\n        setSelectedUser,\n        messages,\n        loading,\n        handleSendMessage,\n        handleAddReaction,\n        handleReplyToMessage,\n        socketConnected: connected\n      }}\n    >\n      {children}\n    </ChatContext.Provider>\n  );\n};"],"mappings":"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","ignoreList":[]},"metadata":{},"sourceType":"module","externalDependencies":[]}