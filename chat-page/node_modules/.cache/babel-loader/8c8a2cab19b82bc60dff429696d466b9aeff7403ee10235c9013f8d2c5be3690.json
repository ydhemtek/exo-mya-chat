{"ast":null,"code":"var _jsxFileName = \"/home/mehdycament/Bureau/app_message_symfony/chat-page/src/contexts/ChatContext.js\",\n  _s = $RefreshSig$();\nimport React, { createContext, useState, useEffect, useContext } from 'react';\nimport { getUsers, getMessages, sendMessage, addReaction, replyToMessage } from '../services/chatService';\nimport { AuthContext } from './AuthContext';\nimport io from 'socket.io-client';\nimport { jsxDEV as _jsxDEV } from \"react/jsx-dev-runtime\";\nexport const ChatContext = /*#__PURE__*/createContext();\n\n// Connexion socket.io pour les communications en temps réel\nconst SOCKET_URL = 'http://localhost:5000'; // URL du serveur de socket\nlet socket;\nexport const ChatProvider = ({\n  children\n}) => {\n  _s();\n  const {\n    currentUser\n  } = useContext(AuthContext);\n  const [onlineUsers, setOnlineUsers] = useState([]);\n  const [selectedUser, setSelectedUser] = useState(null);\n  const [messages, setMessages] = useState([]);\n  const [loading, setLoading] = useState(false);\n\n  // Établir la connexion socket quand l'utilisateur est connecté\n  useEffect(() => {\n    if (currentUser) {\n      socket = io(SOCKET_URL);\n\n      // Connexion de l'utilisateur\n      socket.emit('user_connected', {\n        userId: currentUser.id,\n        username: currentUser.username\n      });\n\n      // Écouter les mises à jour des utilisateurs en ligne\n      socket.on('online_users', users => {\n        setOnlineUsers(users.filter(user => user.id !== currentUser.id));\n      });\n\n      // Écouter les nouveaux messages\n      socket.on('new_message', message => {\n        setMessages(prevMessages => [...prevMessages, message]);\n      });\n\n      // Écouter les nouvelles réactions\n      socket.on('new_reaction', ({\n        messageId,\n        reaction,\n        userId\n      }) => {\n        setMessages(prevMessages => prevMessages.map(msg => msg.id === messageId ? {\n          ...msg,\n          reactions: [...(msg.reactions || []), {\n            reaction,\n            userId\n          }]\n        } : msg));\n      });\n\n      // Écouter les nouvelles réponses\n      socket.on('new_reply', ({\n        messageId,\n        reply\n      }) => {\n        setMessages(prevMessages => prevMessages.map(msg => msg.id === messageId ? {\n          ...msg,\n          replies: [...(msg.replies || []), reply]\n        } : msg));\n      });\n      return () => {\n        // Déconnexion du socket lorsque le composant est démonté\n        socket.disconnect();\n      };\n    }\n  }, [currentUser]);\n\n  // Charger les messages lorsqu'un utilisateur est sélectionné\n  useEffect(() => {\n    if (selectedUser) {\n      fetchMessages(selectedUser.id);\n    }\n  }, [selectedUser]);\n\n  // Charger la liste des utilisateurs\n  const fetchUsers = async () => {\n    try {\n      const users = await getUsers();\n      return users;\n    } catch (error) {\n      console.error('Error fetching users:', error);\n      return [];\n    }\n  };\n\n  // Charger les messages avec un utilisateur spécifique\n  const fetchMessages = async userId => {\n    try {\n      setLoading(true);\n      const messagesData = await getMessages(userId);\n      setMessages(messagesData);\n      setLoading(false);\n    } catch (error) {\n      console.error('Error fetching messages:', error);\n      setLoading(false);\n    }\n  };\n\n  // Envoyer un message\n  const handleSendMessage = async content => {\n    if (!selectedUser) return;\n    try {\n      const newMessage = {\n        sender: currentUser.id,\n        receiver: selectedUser.id,\n        content,\n        timestamp: new Date().toISOString(),\n        reactions: [],\n        replies: []\n      };\n\n      // Ajouter le message localement avant d'obtenir une réponse du serveur\n      setMessages(prevMessages => [...prevMessages, newMessage]);\n\n      // Envoyer le message via socket\n      socket.emit('send_message', newMessage);\n\n      // Enregistrer le message dans la base de données\n      await sendMessage(newMessage);\n    } catch (error) {\n      console.error('Error sending message:', error);\n    }\n  };\n\n  // Ajouter une réaction à un message\n  const handleAddReaction = async (messageId, reaction) => {\n    try {\n      // Mettre à jour localement\n      setMessages(prevMessages => prevMessages.map(msg => msg.id === messageId ? {\n        ...msg,\n        reactions: [...(msg.reactions || []), {\n          reaction,\n          userId: currentUser.id\n        }]\n      } : msg));\n\n      // Envoyer via socket\n      socket.emit('add_reaction', {\n        messageId,\n        reaction,\n        userId: currentUser.id\n      });\n\n      // Enregistrer dans la base de données\n      await addReaction(messageId, reaction);\n    } catch (error) {\n      console.error('Error adding reaction:', error);\n    }\n  };\n\n  // Répondre à un message\n  const handleReplyToMessage = async (messageId, content) => {\n    try {\n      const reply = {\n        sender: currentUser.id,\n        content,\n        timestamp: new Date().toISOString(),\n        parentId: messageId\n      };\n\n      // Mettre à jour localement\n      setMessages(prevMessages => prevMessages.map(msg => msg.id === messageId ? {\n        ...msg,\n        replies: [...(msg.replies || []), reply]\n      } : msg));\n\n      // Envoyer via socket\n      socket.emit('reply_to_message', {\n        messageId,\n        reply\n      });\n\n      // Enregistrer dans la base de données\n      await replyToMessage(messageId, content);\n    } catch (error) {\n      console.error('Error replying to message:', error);\n    }\n  };\n  return /*#__PURE__*/_jsxDEV(ChatContext.Provider, {\n    value: {\n      onlineUsers,\n      fetchUsers,\n      selectedUser,\n      setSelectedUser,\n      messages,\n      loading,\n      handleSendMessage,\n      handleAddReaction,\n      handleReplyToMessage\n    },\n    children: children\n  }, void 0, false, {\n    fileName: _jsxFileName,\n    lineNumber: 188,\n    columnNumber: 5\n  }, this);\n};\n_s(ChatProvider, \"3jqZdAP1PW+qzjh70pc+gLlSIq4=\");\n_c = ChatProvider;\nvar _c;\n$RefreshReg$(_c, \"ChatProvider\");","map":{"version":3,"names":["React","createContext","useState","useEffect","useContext","getUsers","getMessages","sendMessage","addReaction","replyToMessage","AuthContext","io","jsxDEV","_jsxDEV","ChatContext","SOCKET_URL","socket","ChatProvider","children","_s","currentUser","onlineUsers","setOnlineUsers","selectedUser","setSelectedUser","messages","setMessages","loading","setLoading","emit","userId","id","username","on","users","filter","user","message","prevMessages","messageId","reaction","map","msg","reactions","reply","replies","disconnect","fetchMessages","fetchUsers","error","console","messagesData","handleSendMessage","content","newMessage","sender","receiver","timestamp","Date","toISOString","handleAddReaction","handleReplyToMessage","parentId","Provider","value","fileName","_jsxFileName","lineNumber","columnNumber","_c","$RefreshReg$"],"sources":["/home/mehdycament/Bureau/app_message_symfony/chat-page/src/contexts/ChatContext.js"],"sourcesContent":["import React, { createContext, useState, useEffect, useContext } from 'react';\nimport { getUsers, getMessages, sendMessage, addReaction, replyToMessage } from '../services/chatService';\nimport { AuthContext } from './AuthContext';\nimport io from 'socket.io-client';\n\nexport const ChatContext = createContext();\n\n// Connexion socket.io pour les communications en temps réel\nconst SOCKET_URL = 'http://localhost:5000'; // URL du serveur de socket\nlet socket;\n\nexport const ChatProvider = ({ children }) => {\n  const { currentUser } = useContext(AuthContext);\n  const [onlineUsers, setOnlineUsers] = useState([]);\n  const [selectedUser, setSelectedUser] = useState(null);\n  const [messages, setMessages] = useState([]);\n  const [loading, setLoading] = useState(false);\n\n  // Établir la connexion socket quand l'utilisateur est connecté\n  useEffect(() => {\n    if (currentUser) {\n      socket = io(SOCKET_URL);\n      \n      // Connexion de l'utilisateur\n      socket.emit('user_connected', { userId: currentUser.id, username: currentUser.username });\n      \n      // Écouter les mises à jour des utilisateurs en ligne\n      socket.on('online_users', (users) => {\n        setOnlineUsers(users.filter(user => user.id !== currentUser.id));\n      });\n      \n      // Écouter les nouveaux messages\n      socket.on('new_message', (message) => {\n        setMessages(prevMessages => [...prevMessages, message]);\n      });\n      \n      // Écouter les nouvelles réactions\n      socket.on('new_reaction', ({ messageId, reaction, userId }) => {\n        setMessages(prevMessages => \n          prevMessages.map(msg => \n            msg.id === messageId \n              ? { \n                  ...msg, \n                  reactions: [...(msg.reactions || []), { reaction, userId }] \n                } \n              : msg\n          )\n        );\n      });\n      \n      // Écouter les nouvelles réponses\n      socket.on('new_reply', ({ messageId, reply }) => {\n        setMessages(prevMessages => \n          prevMessages.map(msg => \n            msg.id === messageId \n              ? { \n                  ...msg, \n                  replies: [...(msg.replies || []), reply] \n                } \n              : msg\n          )\n        );\n      });\n      \n      return () => {\n        // Déconnexion du socket lorsque le composant est démonté\n        socket.disconnect();\n      };\n    }\n  }, [currentUser]);\n\n  // Charger les messages lorsqu'un utilisateur est sélectionné\n  useEffect(() => {\n    if (selectedUser) {\n      fetchMessages(selectedUser.id);\n    }\n  }, [selectedUser]);\n\n  // Charger la liste des utilisateurs\n  const fetchUsers = async () => {\n    try {\n      const users = await getUsers();\n      return users;\n    } catch (error) {\n      console.error('Error fetching users:', error);\n      return [];\n    }\n  };\n\n  // Charger les messages avec un utilisateur spécifique\n  const fetchMessages = async (userId) => {\n    try {\n      setLoading(true);\n      const messagesData = await getMessages(userId);\n      setMessages(messagesData);\n      setLoading(false);\n    } catch (error) {\n      console.error('Error fetching messages:', error);\n      setLoading(false);\n    }\n  };\n\n  // Envoyer un message\n  const handleSendMessage = async (content) => {\n    if (!selectedUser) return;\n    \n    try {\n      const newMessage = {\n        sender: currentUser.id,\n        receiver: selectedUser.id,\n        content,\n        timestamp: new Date().toISOString(),\n        reactions: [],\n        replies: []\n      };\n      \n      // Ajouter le message localement avant d'obtenir une réponse du serveur\n      setMessages(prevMessages => [...prevMessages, newMessage]);\n      \n      // Envoyer le message via socket\n      socket.emit('send_message', newMessage);\n      \n      // Enregistrer le message dans la base de données\n      await sendMessage(newMessage);\n    } catch (error) {\n      console.error('Error sending message:', error);\n    }\n  };\n\n  // Ajouter une réaction à un message\n  const handleAddReaction = async (messageId, reaction) => {\n    try {\n      // Mettre à jour localement\n      setMessages(prevMessages => \n        prevMessages.map(msg => \n          msg.id === messageId \n            ? { \n                ...msg, \n                reactions: [...(msg.reactions || []), { reaction, userId: currentUser.id }] \n              } \n            : msg\n        )\n      );\n      \n      // Envoyer via socket\n      socket.emit('add_reaction', { messageId, reaction, userId: currentUser.id });\n      \n      // Enregistrer dans la base de données\n      await addReaction(messageId, reaction);\n    } catch (error) {\n      console.error('Error adding reaction:', error);\n    }\n  };\n\n  // Répondre à un message\n  const handleReplyToMessage = async (messageId, content) => {\n    try {\n      const reply = {\n        sender: currentUser.id,\n        content,\n        timestamp: new Date().toISOString(),\n        parentId: messageId\n      };\n      \n      // Mettre à jour localement\n      setMessages(prevMessages => \n        prevMessages.map(msg => \n          msg.id === messageId \n            ? { \n                ...msg, \n                replies: [...(msg.replies || []), reply] \n              } \n            : msg\n        )\n      );\n      \n      // Envoyer via socket\n      socket.emit('reply_to_message', { messageId, reply });\n      \n      // Enregistrer dans la base de données\n      await replyToMessage(messageId, content);\n    } catch (error) {\n      console.error('Error replying to message:', error);\n    }\n  };\n\n  return (\n    <ChatContext.Provider\n      value={{\n        onlineUsers,\n        fetchUsers,\n        selectedUser,\n        setSelectedUser,\n        messages,\n        loading,\n        handleSendMessage,\n        handleAddReaction,\n        handleReplyToMessage\n      }}\n    >\n      {children}\n    </ChatContext.Provider>\n  );\n};"],"mappings":"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","ignoreList":[]},"metadata":{},"sourceType":"module","externalDependencies":[]}