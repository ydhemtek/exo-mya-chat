{"ast":null,"code":"var _jsxFileName = \"/home/mehdycament/Bureau/app_message_symfony/chat-page/src/contexts/ChatContext.js\",\n  _s = $RefreshSig$();\nimport React, { createContext, useState, useEffect, useContext, useCallback } from 'react';\nimport { AuthContext } from './AuthContext';\nimport io from 'socket.io-client';\nimport { jsxDEV as _jsxDEV } from \"react/jsx-dev-runtime\";\nexport const ChatContext = /*#__PURE__*/createContext();\n\n// URL du serveur socket.io\nconst SOCKET_URL = 'http://localhost:5001'; // Changé à 5001 pour éviter le conflit de port\nlet socket;\nexport const ChatProvider = ({\n  children\n}) => {\n  _s();\n  const {\n    currentUser\n  } = useContext(AuthContext);\n  const [onlineUsers, setOnlineUsers] = useState([]);\n  const [selectedUser, setSelectedUser] = useState(null);\n  const [messages, setMessages] = useState([]);\n  const [loading, setLoading] = useState(false);\n  const [connected, setConnected] = useState(false);\n\n  // Fonction pour se connecter au serveur socket\n  const connectSocket = useCallback(() => {\n    if (!socket) {\n      console.log('Initialisation de la connexion socket...');\n      socket = io(SOCKET_URL, {\n        reconnectionAttempts: 5,\n        reconnectionDelay: 1000,\n        timeout: 10000\n      });\n\n      // Ecouter la connexion\n      socket.on('connect', () => {\n        console.log('Connecté au serveur socket avec id:', socket.id);\n        setConnected(true);\n      });\n\n      // Ecouter les erreurs de connexion\n      socket.on('connect_error', error => {\n        console.error('Erreur de connexion socket:', error);\n\n        // Solution temporaire : ajouter des utilisateurs fictifs pour tester l'interface\n        if (currentUser) {\n          const fakeUsers = [{\n            id: 'user1',\n            username: 'Alice',\n            isOnline: true\n          }, {\n            id: 'user2',\n            username: 'Bob',\n            isOnline: true\n          }, {\n            id: 'user3',\n            username: 'Charlie',\n            isOnline: true\n          }].filter(user => user.id !== currentUser.id);\n          console.log('Utilisation de données fictives pour les tests:', fakeUsers);\n          setOnlineUsers(fakeUsers);\n        }\n      });\n\n      // Ecouter la déconnexion\n      socket.on('disconnect', reason => {\n        console.log('Déconnecté du serveur socket. Raison:', reason);\n        setConnected(false);\n      });\n    }\n  }, [currentUser]);\n\n  // Établir la connexion socket quand l'utilisateur est connecté\n  useEffect(() => {\n    if (currentUser) {\n      // Établir la connexion au serveur socket\n      connectSocket();\n      if (socket) {\n        // Enregistrer l'utilisateur sur le serveur\n        console.log('Enregistrement de l\\'utilisateur:', currentUser);\n        socket.emit('register', {\n          ...currentUser,\n          socketId: socket.id\n        });\n\n        // Configurer les écouteurs d'événements\n\n        // Écouter les mises à jour des utilisateurs en ligne\n        socket.on('users_update', users => {\n          console.log('Utilisateurs en ligne reçus:', users);\n          if (Array.isArray(users)) {\n            // Filtrer pour exclure l'utilisateur courant\n            const otherUsers = users.filter(user => user.id !== currentUser.id && user.isOnline);\n            console.log('Autres utilisateurs filtrés:', otherUsers);\n            setOnlineUsers(otherUsers);\n          } else {\n            console.error('Format incorrect pour users_update, attendu tableau, reçu:', typeof users);\n          }\n        });\n\n        // Écouter les nouveaux messages\n        socket.on('new_message', message => {\n          console.log('Nouveau message reçu:', message);\n          setMessages(prevMessages => [...prevMessages, message]);\n        });\n\n        // Confirmation d'envoi de message\n        socket.on('message_sent', message => {\n          console.log('Confirmation de message envoyé:', message);\n          setMessages(prevMessages => prevMessages.map(msg => msg.id === message.id ? message : msg));\n        });\n\n        // Écouter les nouvelles réactions\n        socket.on('new_reaction', data => {\n          console.log('Nouvelle réaction reçue:', data);\n          setMessages(prevMessages => prevMessages.map(msg => msg.id === data.messageId ? {\n            ...msg,\n            reactions: [...(msg.reactions || []), {\n              reaction: data.reaction,\n              userId: data.userId\n            }]\n          } : msg));\n        });\n\n        // Écouter les nouvelles réponses\n        socket.on('new_reply', data => {\n          console.log('Nouvelle réponse reçue:', data);\n          setMessages(prevMessages => prevMessages.map(msg => msg.id === data.messageId ? {\n            ...msg,\n            replies: [...(msg.replies || []), data.reply]\n          } : msg));\n        });\n      }\n    }\n    return () => {\n      if (socket) {\n        console.log('Nettoyage des écouteurs d\\'événements socket');\n        socket.off('users_update');\n        socket.off('new_message');\n        socket.off('message_sent');\n        socket.off('new_reaction');\n        socket.off('new_reply');\n      }\n    };\n  }, [currentUser, connectSocket]);\n\n  // Charger les messages lorsqu'un utilisateur est sélectionné\n  useEffect(() => {\n    if (selectedUser) {\n      console.log('Utilisateur sélectionné:', selectedUser);\n      setLoading(true);\n      setMessages([]); // Réinitialiser les messages\n\n      // Dans une vraie application, on récupérerait l'historique des messages depuis le serveur\n      // Pour l'instant, on crée des messages fictifs pour tester\n      const now = new Date();\n      const fakeMessages = [{\n        id: 'm1',\n        sender: selectedUser.id,\n        receiver: currentUser === null || currentUser === void 0 ? void 0 : currentUser.id,\n        content: 'Bonjour ! Comment allez-vous ?',\n        timestamp: new Date(now.getTime() - 3600000).toISOString(),\n        status: 'read'\n      }, {\n        id: 'm2',\n        sender: currentUser === null || currentUser === void 0 ? void 0 : currentUser.id,\n        receiver: selectedUser.id,\n        content: 'Très bien, merci ! Et vous ?',\n        timestamp: new Date(now.getTime() - 3000000).toISOString(),\n        status: 'read'\n      }];\n      setMessages(fakeMessages);\n      setLoading(false);\n    }\n  }, [selectedUser, currentUser]);\n\n  // Demander explicitement la liste des utilisateurs\n  const fetchUsers = useCallback(async () => {\n    console.log('Récupération des utilisateurs...');\n    if (socket && connected) {\n      socket.emit('get_users');\n      console.log('Demande de liste d\\'utilisateurs envoyée');\n    }\n\n    // Pour les tests, retourner aussi des utilisateurs fictifs si pas d'utilisateurs en ligne\n    if (onlineUsers.length === 0) {\n      const fakeUsers = [{\n        id: 'user1',\n        username: 'Alice',\n        isOnline: true\n      }, {\n        id: 'user2',\n        username: 'Bob',\n        isOnline: true\n      }, {\n        id: 'user3',\n        username: 'Charlie',\n        isOnline: true\n      }].filter(user => user.id !== (currentUser === null || currentUser === void 0 ? void 0 : currentUser.id));\n      console.log('Utilisation d\\'utilisateurs fictifs:', fakeUsers);\n      return fakeUsers;\n    }\n    return onlineUsers;\n  }, [onlineUsers, socket, connected, currentUser]);\n\n  // Envoyer un message\n  const handleSendMessage = useCallback(async content => {\n    if (!selectedUser || !currentUser) {\n      console.error('Impossible d\\'envoyer un message: pas d\\'utilisateur sélectionné ou courant');\n      return;\n    }\n    console.log('Envoi d\\'un message à:', selectedUser.username);\n    try {\n      const newMessage = {\n        id: `m${Date.now()}`,\n        sender: currentUser.id,\n        receiver: selectedUser.id,\n        content,\n        timestamp: new Date().toISOString(),\n        status: 'sending'\n      };\n\n      // Ajouter le message localement avant d'obtenir une réponse du serveur\n      setMessages(prevMessages => [...prevMessages, newMessage]);\n\n      // Envoyer le message via socket si connecté\n      if (socket && connected) {\n        console.log('Émission du message via socket');\n        socket.emit('send_message', newMessage);\n      } else {\n        console.log('Socket non connecté, message enregistré uniquement localement');\n        // Simuler un succès d'envoi pour le testing\n        setTimeout(() => {\n          setMessages(prevMessages => prevMessages.map(msg => msg.id === newMessage.id ? {\n            ...msg,\n            status: 'delivered'\n          } : msg));\n        }, 1000);\n      }\n    } catch (error) {\n      console.error('Erreur lors de l\\'envoi du message:', error);\n    }\n  }, [selectedUser, currentUser, socket, connected]);\n\n  // Ajouter une réaction à un message\n  const handleAddReaction = useCallback(async (messageId, reaction) => {\n    console.log('Ajout d\\'une réaction:', reaction, 'au message:', messageId);\n    try {\n      if (!currentUser) {\n        console.error('Impossible d\\'ajouter une réaction: pas d\\'utilisateur courant');\n        return;\n      }\n\n      // Mettre à jour localement\n      setMessages(prevMessages => prevMessages.map(msg => msg.id === messageId ? {\n        ...msg,\n        reactions: [...(msg.reactions || []), {\n          reaction,\n          userId: currentUser.id,\n          timestamp: new Date().toISOString()\n        }]\n      } : msg));\n\n      // Envoyer via socket si connecté\n      if (socket && connected) {\n        console.log('Émission de la réaction via socket');\n        socket.emit('add_reaction', {\n          messageId,\n          reaction,\n          userId: currentUser.id\n        });\n      } else {\n        console.log('Socket non connecté, réaction enregistrée uniquement localement');\n      }\n    } catch (error) {\n      console.error('Erreur lors de l\\'ajout de la réaction:', error);\n    }\n  }, [currentUser, socket, connected]);\n\n  // Répondre à un message\n  const handleReplyToMessage = useCallback(async (messageId, content) => {\n    console.log('Réponse au message:', messageId);\n    try {\n      if (!currentUser || !selectedUser) {\n        console.error('Impossible de répondre: pas d\\'utilisateur courant ou sélectionné');\n        return;\n      }\n      const parentMessage = messages.find(msg => msg.id === messageId);\n      if (!parentMessage) {\n        console.error('Message parent introuvable');\n        return;\n      }\n      const reply = {\n        id: `reply_${Date.now()}`,\n        sender: currentUser.id,\n        receiver: selectedUser.id,\n        content,\n        timestamp: new Date().toISOString(),\n        parentId: messageId,\n        parentMessage: {\n          id: parentMessage.id,\n          content: parentMessage.content\n        }\n      };\n\n      // Mettre à jour localement\n      setMessages(prevMessages => prevMessages.map(msg => msg.id === messageId ? {\n        ...msg,\n        replies: [...(msg.replies || []), reply]\n      } : msg));\n\n      // Envoyer via socket si connecté\n      if (socket && connected) {\n        console.log('Émission de la réponse via socket');\n        socket.emit('reply_to_message', {\n          messageId,\n          reply\n        });\n      } else {\n        console.log('Socket non connecté, réponse enregistrée uniquement localement');\n      }\n    } catch (error) {\n      console.error('Erreur lors de la réponse au message:', error);\n    }\n  }, [currentUser, selectedUser, messages, socket, connected]);\n\n  // Forcer la reconnexion au serveur socket\n  const reconnect = useCallback(() => {\n    console.log('Tentative de reconnexion au serveur socket...');\n    if (socket) {\n      socket.disconnect();\n      socket = null;\n    }\n    connectSocket();\n  }, [connectSocket]);\n  return /*#__PURE__*/_jsxDEV(ChatContext.Provider, {\n    value: {\n      onlineUsers,\n      fetchUsers,\n      selectedUser,\n      setSelectedUser,\n      messages,\n      loading,\n      handleSendMessage,\n      handleAddReaction,\n      handleReplyToMessage,\n      socketConnected: connected,\n      reconnect\n    },\n    children: children\n  }, void 0, false, {\n    fileName: _jsxFileName,\n    lineNumber: 363,\n    columnNumber: 5\n  }, this);\n};\n_s(ChatProvider, \"rD/Kwdl2NZ2qU9lSqnhrnE6i25M=\");\n_c = ChatProvider;\nvar _c;\n$RefreshReg$(_c, \"ChatProvider\");","map":{"version":3,"names":["React","createContext","useState","useEffect","useContext","useCallback","AuthContext","io","jsxDEV","_jsxDEV","ChatContext","SOCKET_URL","socket","ChatProvider","children","_s","currentUser","onlineUsers","setOnlineUsers","selectedUser","setSelectedUser","messages","setMessages","loading","setLoading","connected","setConnected","connectSocket","console","log","reconnectionAttempts","reconnectionDelay","timeout","on","id","error","fakeUsers","username","isOnline","filter","user","reason","emit","socketId","users","Array","isArray","otherUsers","message","prevMessages","map","msg","data","messageId","reactions","reaction","userId","replies","reply","off","now","Date","fakeMessages","sender","receiver","content","timestamp","getTime","toISOString","status","fetchUsers","length","handleSendMessage","newMessage","setTimeout","handleAddReaction","handleReplyToMessage","parentMessage","find","parentId","reconnect","disconnect","Provider","value","socketConnected","fileName","_jsxFileName","lineNumber","columnNumber","_c","$RefreshReg$"],"sources":["/home/mehdycament/Bureau/app_message_symfony/chat-page/src/contexts/ChatContext.js"],"sourcesContent":["import React, { createContext, useState, useEffect, useContext, useCallback } from 'react';\nimport { AuthContext } from './AuthContext';\nimport io from 'socket.io-client';\n\nexport const ChatContext = createContext();\n\n// URL du serveur socket.io\nconst SOCKET_URL = 'http://localhost:5001'; // Changé à 5001 pour éviter le conflit de port\nlet socket;\n\nexport const ChatProvider = ({ children }) => {\n  const { currentUser } = useContext(AuthContext);\n  const [onlineUsers, setOnlineUsers] = useState([]);\n  const [selectedUser, setSelectedUser] = useState(null);\n  const [messages, setMessages] = useState([]);\n  const [loading, setLoading] = useState(false);\n  const [connected, setConnected] = useState(false);\n\n  // Fonction pour se connecter au serveur socket\n  const connectSocket = useCallback(() => {\n    if (!socket) {\n      console.log('Initialisation de la connexion socket...');\n      socket = io(SOCKET_URL, {\n        reconnectionAttempts: 5,\n        reconnectionDelay: 1000,\n        timeout: 10000\n      });\n\n      // Ecouter la connexion\n      socket.on('connect', () => {\n        console.log('Connecté au serveur socket avec id:', socket.id);\n        setConnected(true);\n      });\n\n      // Ecouter les erreurs de connexion\n      socket.on('connect_error', (error) => {\n        console.error('Erreur de connexion socket:', error);\n        \n        // Solution temporaire : ajouter des utilisateurs fictifs pour tester l'interface\n        if (currentUser) {\n          const fakeUsers = [\n            { id: 'user1', username: 'Alice', isOnline: true },\n            { id: 'user2', username: 'Bob', isOnline: true },\n            { id: 'user3', username: 'Charlie', isOnline: true }\n          ].filter(user => user.id !== currentUser.id);\n          \n          console.log('Utilisation de données fictives pour les tests:', fakeUsers);\n          setOnlineUsers(fakeUsers);\n        }\n      });\n\n      // Ecouter la déconnexion\n      socket.on('disconnect', (reason) => {\n        console.log('Déconnecté du serveur socket. Raison:', reason);\n        setConnected(false);\n      });\n    }\n  }, [currentUser]);\n\n  // Établir la connexion socket quand l'utilisateur est connecté\n  useEffect(() => {\n    if (currentUser) {\n      // Établir la connexion au serveur socket\n      connectSocket();\n      \n      if (socket) {\n        // Enregistrer l'utilisateur sur le serveur\n        console.log('Enregistrement de l\\'utilisateur:', currentUser);\n        socket.emit('register', {\n          ...currentUser,\n          socketId: socket.id\n        });\n        \n        // Configurer les écouteurs d'événements\n        \n        // Écouter les mises à jour des utilisateurs en ligne\n        socket.on('users_update', (users) => {\n          console.log('Utilisateurs en ligne reçus:', users);\n          \n          if (Array.isArray(users)) {\n            // Filtrer pour exclure l'utilisateur courant\n            const otherUsers = users.filter(user => \n              user.id !== currentUser.id && user.isOnline\n            );\n            console.log('Autres utilisateurs filtrés:', otherUsers);\n            setOnlineUsers(otherUsers);\n          } else {\n            console.error('Format incorrect pour users_update, attendu tableau, reçu:', typeof users);\n          }\n        });\n        \n        // Écouter les nouveaux messages\n        socket.on('new_message', (message) => {\n          console.log('Nouveau message reçu:', message);\n          setMessages(prevMessages => [...prevMessages, message]);\n        });\n        \n        // Confirmation d'envoi de message\n        socket.on('message_sent', (message) => {\n          console.log('Confirmation de message envoyé:', message);\n          setMessages(prevMessages => \n            prevMessages.map(msg => \n              msg.id === message.id ? message : msg\n            )\n          );\n        });\n        \n        // Écouter les nouvelles réactions\n        socket.on('new_reaction', (data) => {\n          console.log('Nouvelle réaction reçue:', data);\n          setMessages(prevMessages => \n            prevMessages.map(msg => \n              msg.id === data.messageId \n                ? { \n                    ...msg, \n                    reactions: [...(msg.reactions || []), { \n                      reaction: data.reaction, \n                      userId: data.userId \n                    }] \n                  } \n                : msg\n            )\n          );\n        });\n        \n        // Écouter les nouvelles réponses\n        socket.on('new_reply', (data) => {\n          console.log('Nouvelle réponse reçue:', data);\n          setMessages(prevMessages => \n            prevMessages.map(msg => \n              msg.id === data.messageId \n                ? { \n                    ...msg, \n                    replies: [...(msg.replies || []), data.reply] \n                  } \n                : msg\n            )\n          );\n        });\n      }\n    }\n    \n    return () => {\n      if (socket) {\n        console.log('Nettoyage des écouteurs d\\'événements socket');\n        socket.off('users_update');\n        socket.off('new_message');\n        socket.off('message_sent');\n        socket.off('new_reaction');\n        socket.off('new_reply');\n      }\n    };\n  }, [currentUser, connectSocket]);\n\n  // Charger les messages lorsqu'un utilisateur est sélectionné\n  useEffect(() => {\n    if (selectedUser) {\n      console.log('Utilisateur sélectionné:', selectedUser);\n      setLoading(true);\n      setMessages([]); // Réinitialiser les messages\n      \n      // Dans une vraie application, on récupérerait l'historique des messages depuis le serveur\n      // Pour l'instant, on crée des messages fictifs pour tester\n      const now = new Date();\n      const fakeMessages = [\n        {\n          id: 'm1',\n          sender: selectedUser.id,\n          receiver: currentUser?.id,\n          content: 'Bonjour ! Comment allez-vous ?',\n          timestamp: new Date(now.getTime() - 3600000).toISOString(),\n          status: 'read'\n        },\n        {\n          id: 'm2',\n          sender: currentUser?.id,\n          receiver: selectedUser.id,\n          content: 'Très bien, merci ! Et vous ?',\n          timestamp: new Date(now.getTime() - 3000000).toISOString(),\n          status: 'read'\n        }\n      ];\n      \n      setMessages(fakeMessages);\n      setLoading(false);\n    }\n  }, [selectedUser, currentUser]);\n\n  // Demander explicitement la liste des utilisateurs\n  const fetchUsers = useCallback(async () => {\n    console.log('Récupération des utilisateurs...');\n    if (socket && connected) {\n      socket.emit('get_users');\n      console.log('Demande de liste d\\'utilisateurs envoyée');\n    }\n    \n    // Pour les tests, retourner aussi des utilisateurs fictifs si pas d'utilisateurs en ligne\n    if (onlineUsers.length === 0) {\n      const fakeUsers = [\n        { id: 'user1', username: 'Alice', isOnline: true },\n        { id: 'user2', username: 'Bob', isOnline: true },\n        { id: 'user3', username: 'Charlie', isOnline: true }\n      ].filter(user => user.id !== currentUser?.id);\n      \n      console.log('Utilisation d\\'utilisateurs fictifs:', fakeUsers);\n      return fakeUsers;\n    }\n    \n    return onlineUsers;\n  }, [onlineUsers, socket, connected, currentUser]);\n\n  // Envoyer un message\n  const handleSendMessage = useCallback(async (content) => {\n    if (!selectedUser || !currentUser) {\n      console.error('Impossible d\\'envoyer un message: pas d\\'utilisateur sélectionné ou courant');\n      return;\n    }\n    \n    console.log('Envoi d\\'un message à:', selectedUser.username);\n    \n    try {\n      const newMessage = {\n        id: `m${Date.now()}`,\n        sender: currentUser.id,\n        receiver: selectedUser.id,\n        content,\n        timestamp: new Date().toISOString(),\n        status: 'sending'\n      };\n      \n      // Ajouter le message localement avant d'obtenir une réponse du serveur\n      setMessages(prevMessages => [...prevMessages, newMessage]);\n      \n      // Envoyer le message via socket si connecté\n      if (socket && connected) {\n        console.log('Émission du message via socket');\n        socket.emit('send_message', newMessage);\n      } else {\n        console.log('Socket non connecté, message enregistré uniquement localement');\n        // Simuler un succès d'envoi pour le testing\n        setTimeout(() => {\n          setMessages(prevMessages => \n            prevMessages.map(msg => \n              msg.id === newMessage.id \n                ? { ...msg, status: 'delivered' } \n                : msg\n            )\n          );\n        }, 1000);\n      }\n    } catch (error) {\n      console.error('Erreur lors de l\\'envoi du message:', error);\n    }\n  }, [selectedUser, currentUser, socket, connected]);\n\n  // Ajouter une réaction à un message\n  const handleAddReaction = useCallback(async (messageId, reaction) => {\n    console.log('Ajout d\\'une réaction:', reaction, 'au message:', messageId);\n    \n    try {\n      if (!currentUser) {\n        console.error('Impossible d\\'ajouter une réaction: pas d\\'utilisateur courant');\n        return;\n      }\n      \n      // Mettre à jour localement\n      setMessages(prevMessages => \n        prevMessages.map(msg => \n          msg.id === messageId \n            ? { \n                ...msg, \n                reactions: [...(msg.reactions || []), { \n                  reaction, \n                  userId: currentUser.id,\n                  timestamp: new Date().toISOString()\n                }] \n              } \n            : msg\n        )\n      );\n      \n      // Envoyer via socket si connecté\n      if (socket && connected) {\n        console.log('Émission de la réaction via socket');\n        socket.emit('add_reaction', { \n          messageId, \n          reaction, \n          userId: currentUser.id \n        });\n      } else {\n        console.log('Socket non connecté, réaction enregistrée uniquement localement');\n      }\n    } catch (error) {\n      console.error('Erreur lors de l\\'ajout de la réaction:', error);\n    }\n  }, [currentUser, socket, connected]);\n\n  // Répondre à un message\n  const handleReplyToMessage = useCallback(async (messageId, content) => {\n    console.log('Réponse au message:', messageId);\n    \n    try {\n      if (!currentUser || !selectedUser) {\n        console.error('Impossible de répondre: pas d\\'utilisateur courant ou sélectionné');\n        return;\n      }\n      \n      const parentMessage = messages.find(msg => msg.id === messageId);\n      \n      if (!parentMessage) {\n        console.error('Message parent introuvable');\n        return;\n      }\n      \n      const reply = {\n        id: `reply_${Date.now()}`,\n        sender: currentUser.id,\n        receiver: selectedUser.id,\n        content,\n        timestamp: new Date().toISOString(),\n        parentId: messageId,\n        parentMessage: {\n          id: parentMessage.id,\n          content: parentMessage.content\n        }\n      };\n      \n      // Mettre à jour localement\n      setMessages(prevMessages => \n        prevMessages.map(msg => \n          msg.id === messageId \n            ? { \n                ...msg, \n                replies: [...(msg.replies || []), reply] \n              } \n            : msg\n        )\n      );\n      \n      // Envoyer via socket si connecté\n      if (socket && connected) {\n        console.log('Émission de la réponse via socket');\n        socket.emit('reply_to_message', { messageId, reply });\n      } else {\n        console.log('Socket non connecté, réponse enregistrée uniquement localement');\n      }\n    } catch (error) {\n      console.error('Erreur lors de la réponse au message:', error);\n    }\n  }, [currentUser, selectedUser, messages, socket, connected]);\n\n  // Forcer la reconnexion au serveur socket\n  const reconnect = useCallback(() => {\n    console.log('Tentative de reconnexion au serveur socket...');\n    if (socket) {\n      socket.disconnect();\n      socket = null;\n    }\n    connectSocket();\n  }, [connectSocket]);\n\n  return (\n    <ChatContext.Provider\n      value={{\n        onlineUsers,\n        fetchUsers,\n        selectedUser,\n        setSelectedUser,\n        messages,\n        loading,\n        handleSendMessage,\n        handleAddReaction,\n        handleReplyToMessage,\n        socketConnected: connected,\n        reconnect\n      }}\n    >\n      {children}\n    </ChatContext.Provider>\n  );\n};"],"mappings":"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","ignoreList":[]},"metadata":{},"sourceType":"module","externalDependencies":[]}